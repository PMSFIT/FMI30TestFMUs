<!doctype html>
<html lang=en>
  <head>
    <meta charset=utf-8>
    <title>PMSF FMI 3.0 Test FMUs: Simple Test FMU using FMI 3.0 Array Variables</title>
  </head>
  <body>
    <h1>PMSF Non-normative Test FMUs for FMI 3.0</h1>
    <h2>Simple Test FMU using FMI 3.0 Array Variables</h2>
    <p>This example FMU demonstrates the use of all FMI 3.0 defined
      static array variable types, as well as basic co-simulation.</p>
    <h3>Usage</h3>
    <p>In order to test the proper functioning of the FMU, it is advisable
       to switch on either <code>PUBLIC_LOGGING</code> (which logs via the
       standard FMI logging callback), and/or <code>PRIVATE_LOGGING</code>
       (which logs to a fixed file without interaction with the host
       implementation).  If very fine-grained logging of actual FMI API
       calls is wanted, the flag <code>VERBOSE_FMI_LOGGING</code> can be
       switched on.</p>
    <p>The FMU provides tunable parameter, input, output constant, tunable
       calculated parameter, and output variables for all basic data types
       of FMI 3.0 (i.e. boolean, integer, floating-point, string and binary
       data types) as 2x3 arrays. Enumerations are currently not being
       provided.</p>
    <p>For all types the following calculations are performed element-wise
       on the corresponding array elements:</p>
    <ul>
      <li>For the boolean type, the calculated parameter is calculated as the
        XOR of the tunable parameter and the constant, and the output is
        calculated as the XOR of the input and the tunable parameter.</li>
      <li>For the numeric types, the calculated parameter is calculated as the
        product of the tunable parameter and the constant, and the output is
        calculated as the product of the input and the tunable parameter.</li>
      <li>For the string type, the calculated parameter is calculated as the
        concatenation of the tunable parameter and the constant, and the
        output is calculated as the concatenation of the input and the
        tunable parameter.</li>
      <li>For the binary type, the FMU provides an additional output. The
        calculatedParameter is derived from the tunable parameter by XORing
        each byte with a corresponding byte from the binary constant (rotating
        over those bytes if more bytes are needed). Similarly the second
        binary output will be calculated by XORing each byte of the binary
        input with the corresponding byte of the tunable parameter (again
        wrapping around if necessary), whereas the first output will always be
        a copy of the binary input.</li>
    </ul>
    <h3>Sources</h3>
    <p>Sources and more information can be found on
       <a href="https://github.com/PMSFIT/FMI30TestFMUs">GitHub</a>.</p>
    <h3>Build Information</h3>
    <ul>
        <li><b>FMI Version:</b> @FMU_FMI_VERSION@</li>
        <li><b>Model Name:</b> @FMU_MODEL_NAME@</li>
        <li><b>Instantiation Token:</b> @FMU_TOKEN@</li>
        <li><b>Author:</b> @FMU_AUTHOR@</li>
        <li><b>FMU Version:</b> @FMU_VERSION@</li>
        <li><b>Generation Tool:</b> PMSF Manual FMU Framework</li>
        <li><b>Generation Date And Time:</b> @FMU_TIMESTAMP@</li>
        <li><b>Model Identifier:</b> @FMU_BCS_MODEL_IDENTIFIER@</li>
        <li><b>Target Platform:</b> @FMI_BINARIES_PLATFORM@</li>
        <li><b>Build Option PRIVATE_LOGGING:</b> @PRIVATE_LOGGING@</li>
        <li><b>Build Option PUBLIC_LOGGING:</b> @PUBLIC_LOGGING@</li>
        <li><b>Build Option VERBOSE_FMU_LOGGING:</b> @VERBOSE_FMI_LOGGING@</li>
    </ul>
    <hr>
    <p>©2016–2025 <a href="https://pmsf.eu/">PMSF IT Consulting Pierre R. Mai</a></p>
    <p>See <a href="licenses/license.txt">license.txt</a> for license information.</p>
  </body>
</html>